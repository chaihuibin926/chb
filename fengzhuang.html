<script>
  //向量构造函数
  function Vector(x, y) {
    this.x = x
    this.y = y
  }

  Vector.prototype.plus = function(vector) {
    let result = new Vector()
    result.x = this.x + vector.x   
    result.y = this.y + vector.y
    return result   
  }

  Vector.prototype.sub = function(vector) {
    let result = new Vector()
    result.x = this.x - vector.x   
    result.y = this.y - vector.y
    return result  
  }

  Vector.prototype.mult = function(vector) {
    return this.x * vector.x + this.y * vector.y
  }

  Vector.prototype.getlength = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }



  //复数构造函数
  function Plural(real, imaginary) {
    this.real = real
    this.imaginary = imaginary
    if (this.imaginary > 0) {
      this.compound = `${real} + ${imaginary}i`
    } else if (this.imaginary < 0) {
      this.compound = `${real} - ${-imaginary}i`
    } else {
      this.compound = `${real}`
    }
  }

  Plural.prototype.plus = function(plural) {
    let real = this.real + plural.real
    let imaginary = this.imaginary + plural.imaginary
    let result = new Plural(real, imaginary)
    return result
  }

  Plural.prototype.sub = function(plural) {
    let real = this.real - plural.real
    let imaginary = this.imaginary - plural.imaginary
    let result = new Plural(real, imaginary)
    return result
  }

  Plural.prototype.mult = function(plural) {
    let real = this.real * plural.real - this.imaginary * plural.imaginary
    let imaginary = this.imaginary * plural.real + this.real * plural.imaginary
    let result = new Plural(real, imaginary)
    return result
  }

  Plural.prototype.remove = function(plural) {
    let real = (this.real * plural.real + this.imaginary * plural.imaginary) / (plural.real * plural.real + plural.imaginary * plural.imaginary)
    let imaginary = (this.imaginary * plural.real - this.real * plural.imaginary) / (plural.real * plural.real + plural.imaginary * plural.imaginary)
    let result = new Plural(real, imaginary)
    return result
  }


  //Set构造函数
  function Myset(initial) {
    this.set = []

    if (Array.isArray(initial)) {
      initial.forEach(it => {
        this.add(it)
      })
    }
  }
  
  Myset.prototype.add = function(value) {
    let has = this.has(value)
    if (!has) {
      this.set.push(value)
    }
    return this.set
  }

  Myset.prototype.delete = function(value) {
    let has = this.has(value)
    for (let i = 0; i < this.set.length; i++) {
      if (this.set[i] == value) {
        this.set.splice(i, 1)
      }
      return has
    }
  }

  Myset.prototype.has = function(value) {
    for (let i = 0; i < this.set.length; i++) {
      if (this.set[i] == value) {
        return true
      }
    }
    return false
  }

  Myset.prototype.clear = function() {
    this.set = []
    return this.set
  }

  Object.defineProperty(Myset.prototype, 'size', {
    get() {
      return this.set.length
    }
  })


  //Map
  function Mymap(initialPairs) {
    this._mapKeys = []
    this._mapVals = []

    initialPairs.forEach(pair => {
      let key = pair[0]
      let val = pair[1]
      this.set(key, val)
    })
  }

  Mymap.prototype = {
    set(key, val) {
      if (_keyIdx(key) == -1) {
        this._mapKeys.push(key)
        this._mapVals.push(val)
      } else {
        this._mapVals[_keyIdx(key)] = val
      }
    },
    _keyIdx(key) {
      return this._mapKeys.indexOf(key)
    },
    get(key) {
      if (_keyIdx(key) >= 0) {
        return this._mapVals[_keyIdx(key)]
      }
    },
    has(key) {
      return (_keyIdx(key) >= 0) ? true : false
    },
    clear() {
      this._mapKeys.length = 0
      this._mapVals.length = 0
    },
    delete(key) {
      if (_keyIdx(key) >= 0) {
        this._mapKeys.splice(_keyIdx(key), 1)
        this._mapVals.splice(_keyIdx(key), 1)
      }
    },
    get size() {
      return this._mapKeys.length
    }
  }




  //栈
  function Stack(initial = []) {
    this.head = null
    this._size = 0

    initial.forEach(it => {
      this.push(it)
    })
  }

  Stack.prototype.push = function(value) {
    let node = {
      val: value,
      next: this.head
    }
    this.head = node
    this._size++
    return this
  }

  Stack.prototype.pop = function() {
    if (this.head) {
      let val = this.head.value
      this.head = this.head.next
      this._size--
      return val
    }
  }

  Stack.prototype.peek = function() {
    if (this.head) return this.head.value
  }

  Object.defineProperty(Stack.prototype, 'size', {
    get () {
      return this._size
    }
  })




  //队列
  function Queue(initials = []) {
    this._head = null
    this._tail = null
    this._size = 0

    initial.forEach(it => {
      this.enqueue(it)
    })
  }

  Queue.prototype.enqueue = function(val) {
    let node = {
      val,
      next: null
    }
    if (this._head) {
      this._tail.next = node
      this._tail = node
    } else {
      this._head = this._tail = node
    }
    this._size++
  }

  Queue.prototype.dequeue = function() {
    if (this._head) {
      let val = this._head.val
      this._head = this._head.next
      if (this._head = null) {
        this._tail = null
      }
      this._size--
      return val
    }
  }

  Queue.prototype.peek = function() {
    if (this._head) {
      return this.head.val
    }
  }

  Object.defineProperty(Queue.prototype, 'size', {
    get() {
      return this.size
    }
  })



  class Stack2 {
    // # 私有属性
    #head = null
    #size = 0
    constructor(initial = []) {
      this.head = null
      this._size = 0

      initial.forEach(it => {
        this.push(it)
      })
    }
  }
</script>